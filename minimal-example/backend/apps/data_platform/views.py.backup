import pandas as pd
import json
from django.http import HttpResponse
from django.db import models
from rest_framework import generics, status, viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import SearchFilter, OrderingFilter
from rest_framework.parsers import MultiPartParser, FormParser

from .models import DataSource, Dataset, DataProcessingTask
from .serializers import DataSourceSerializer, DatasetSerializer, DataProcessingTaskSerializer


class DataSourceViewSet(viewsets.ModelViewSet):
    """æ•°æ®æºç®¡ç†ViewSet"""
    queryset = DataSource.objects.all()
    serializer_class = DataSourceSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['source_type', 'is_active', 'organization']
    search_fields = ['name', 'description']
    ordering_fields = ['created_at', 'updated_at', 'name']

    def get_queryset(self):
        """åªè¿”å›å½“å‰ç”¨æˆ·ç»„ç»‡çš„æ•°æ®æº?""
        return DataSource.objects.filter(organization=self.request.user.profile.organization)

    def perform_create(self, serializer):
        """åˆ›å»ºæ•°æ®æºæ—¶è®¾ç½®ç»„ç»‡"""
        serializer.save(
            organization=self.request.user.profile.organization,
            created_by=self.request.user
        )

    @action(detail=True, methods=['post'])
    def test_connection(self, request, pk=None):
        """æµ‹è¯•æ•°æ®æºè¿æ?""
        data_source = self.get_object()
        try:
            # è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„è¿æ¥æµ‹è¯•é€»è¾‘
            # ç›®å‰è¿”å›æ¨¡æ‹Ÿç»“æœ
            return Response({
                'status': 'success',
                'message': f'æˆåŠŸè¿æ¥åˆ°{data_source.name}'
            })
        except Exception as e:
            return Response({
                'status': 'error',
                'message': f'è¿æ¥å¤±è´¥: {str(e)}'
            }, status=status.HTTP_400_BAD_REQUEST)


class DatasetViewSet(viewsets.ModelViewSet):
    """æ•°æ®é›†ç®¡ç†ViewSet"""
    queryset = Dataset.objects.all()
    serializer_class = DatasetSerializer
    permission_classes = [IsAuthenticated]
    parser_classes = [MultiPartParser, FormParser]
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['file_type', 'status', 'data_source']
    search_fields = ['name', 'description']
    ordering_fields = ['created_at', 'updated_at', 'name', 'file_size']

    def get_queryset(self):
        """åªè¿”å›å½“å‰ç”¨æˆ·ç»„ç»‡çš„æ•°æ®é›?""
        return Dataset.objects.filter(uploaded_by__profile__organization=self.request.user.profile.organization)

    def perform_create(self, serializer):
        """åˆ›å»ºæ•°æ®é›†æ—¶è®¾ç½®ä¸Šä¼ è€?""
        serializer.save(uploaded_by=self.request.user)

    @action(detail=True, methods=['get'])
    def preview(self, request, pk=None):
        """é¢„è§ˆæ•°æ®é›†å†…å®?""
        dataset = self.get_object()
        try:
            if dataset.file_type == 'csv' and dataset.file:
                # è¯»å–CSVæ–‡ä»¶å‰å‡ è¡?
                df = pd.read_csv(dataset.file.path, nrows=10)
                preview_data = {
                    'columns': df.columns.tolist(),
                    'data': df.to_dict('records'),
                    'total_rows': len(df),
                    'sample_rows': len(df)
                }
                return Response(preview_data)
            else:
                return Response({
                    'message': 'æš‚ä¸æ”¯æŒè¯¥æ–‡ä»¶ç±»å‹çš„é¢„è§ˆ'
                }, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({
                'error': f'é¢„è§ˆå¤±è´¥: {str(e)}'
            }, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['get'])
    def statistics(self, request, pk=None):
        """è·å–æ•°æ®é›†ç»Ÿè®¡ä¿¡æ?""
        dataset = self.get_object()
        try:
            if dataset.file_type == 'csv' and dataset.file:
                df = pd.read_csv(dataset.file.path)
                stats = {
                    'total_rows': len(df),
                    'total_columns': len(df.columns),
                    'columns': df.columns.tolist(),
                    'data_types': df.dtypes.to_dict(),
                    'missing_values': df.isnull().sum().to_dict(),
                    'numeric_summary': df.describe().to_dict() if not df.select_dtypes(include=['number']).empty else {}
                }
                return Response(stats)
            else:
                return Response({
                    'message': 'æš‚ä¸æ”¯æŒè¯¥æ–‡ä»¶ç±»å‹çš„ç»Ÿè®¡åˆ†æ'
                }, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({
                'error': f'ç»Ÿè®¡åˆ†æå¤±è´¥: {str(e)}'
            }, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['get'])
    def download(self, request, pk=None):
        """ä¸‹è½½æ•°æ®é›†æ–‡ä»?""
        dataset = self.get_object()
        try:
            if dataset.file:
                with open(dataset.file.path, 'rb') as f:
                    response = HttpResponse(f.read(), content_type='application/octet-stream')
                    response['Content-Disposition'] = f'attachment; filename="{dataset.file.name}"'
                    return response
            else:
                return Response({
                    'error': 'æ–‡ä»¶ä¸å­˜åœ?
                }, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            return Response({
                'error': f'ä¸‹è½½å¤±è´¥: {str(e)}'
            }, status=status.HTTP_400_BAD_REQUEST)


class DataProcessingTaskViewSet(viewsets.ModelViewSet):
    """æ•°æ®å¤„ç†ä»»åŠ¡ViewSet"""
    queryset = DataProcessingTask.objects.all()
    serializer_class = DataProcessingTaskSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['task_type', 'status', 'dataset']
    search_fields = ['name', 'description']
    ordering_fields = ['created_at', 'updated_at', 'started_at', 'completed_at']

    def get_queryset(self):
        """åªè¿”å›å½“å‰ç”¨æˆ·ç»„ç»‡çš„å¤„ç†ä»»åŠ¡"""
        return DataProcessingTask.objects.filter(
            created_by__profile__organization=self.request.user.profile.organization
        )

    def perform_create(self, serializer):
        """åˆ›å»ºå¤„ç†ä»»åŠ¡æ—¶è®¾ç½®åˆ›å»ºè€?""
        serializer.save(created_by=self.request.user)

    @action(detail=True, methods=['post'])
    def start(self, request, pk=None):
        """å¯åŠ¨æ•°æ®å¤„ç†ä»»åŠ¡"""
        task = self.get_object()
        try:
            if task.status == 'pending':
                task.status = 'running'
                task.save()
                # è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„ä»»åŠ¡æ‰§è¡Œé€»è¾‘
                # ç›®å‰è¿”å›æ¨¡æ‹Ÿç»“æœ
                return Response({
                    'message': f'ä»»åŠ¡ {task.name} å·²å¯åŠ?
                })
            else:
                return Response({
                    'error': 'åªèƒ½å¯åŠ¨å¾…æ‰§è¡ŒçŠ¶æ€çš„ä»»åŠ¡'
                }, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({
                'error': f'å¯åŠ¨ä»»åŠ¡å¤±è´¥: {str(e)}'
            }, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['post'])
    def stop(self, request, pk=None):
        """åœæ­¢æ•°æ®å¤„ç†ä»»åŠ¡"""
        task = self.get_object()
        try:
            if task.status == 'running':
                task.status = 'stopped'
                task.save()
                return Response({
                    'message': f'ä»»åŠ¡ {task.name} å·²åœæ­?
                })
            else:
                return Response({
                    'error': 'åªèƒ½åœæ­¢è¿è¡Œä¸­çš„ä»»åŠ¡'
                }, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({
                'error': f'åœæ­¢ä»»åŠ¡å¤±è´¥: {str(e)}'
            }, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['get'])
    def logs(self, request, pk=None):
        """è·å–ä»»åŠ¡æ‰§è¡Œæ—¥å¿—"""
        task = self.get_object()
        # è¿™é‡Œå¯ä»¥å®ç°å…·ä½“çš„æ—¥å¿—è·å–é€»è¾‘
        # ç›®å‰è¿”å›æ¨¡æ‹Ÿæ—¥å¿—
        logs = [
            {'timestamp': '2024-01-01 10:00:00', 'level': 'INFO', 'message': 'ä»»åŠ¡å¼€å§‹æ‰§è¡?},
            {'timestamp': '2024-01-01 10:01:00', 'level': 'INFO', 'message': 'æ•°æ®é¢„å¤„ç†å®Œæˆ?},
            {'timestamp': '2024-01-01 10:02:00', 'level': 'INFO', 'message': 'ä»»åŠ¡æ‰§è¡Œå®Œæˆ'},
        ]
        return Response({'logs': logs})
from django_filters.rest_framework import DjangoFilterBackend
from django.utils import timezone
import pandas as pd
import json

from .models import DataSource, Dataset, DataProcessingTask
from .serializers import (
    DataSourceSerializer,
    DatasetSerializer,
    DatasetUploadSerializer,
    DataProcessingTaskSerializer,
    DataProcessingTaskCreateSerializer
)


class DataSourceViewSet(viewsets.ModelViewSet):
    """æ•°æ®æºè§†å›¾é›†"""
    queryset = DataSource.objects.all()
    serializer_class = DataSourceSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['source_type', 'is_active']
    search_fields = ['name', 'description']
    ordering_fields = ['created_at', 'updated_at']
    ordering = ['-created_at']
    
    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)
    
    def get_queryset(self):
        return self.queryset.filter(created_by=self.request.user)


class DatasetViewSet(viewsets.ModelViewSet):
    """æ•°æ®é›†è§†å›¾é›†"""
    queryset = Dataset.objects.all()
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['format', 'is_public']
    search_fields = ['name', 'description']
    ordering_fields = ['created_at', 'updated_at', 'size_bytes']
    ordering = ['-created_at']
    
    def get_serializer_class(self):
        if self.action == 'create':
            return DatasetUploadSerializer
        return DatasetSerializer
    
    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)
    
    def get_queryset(self):
        user = self.request.user
        # è¿”å›ç”¨æˆ·è‡ªå·±çš„æ•°æ®é›†å’Œå…¬å¼€çš„æ•°æ®é›†
        return self.queryset.filter(
            models.Q(created_by=user) | models.Q(is_public=True)
        )
    
    @action(detail=True, methods=['get'])
    def preview(self, request, pk=None):
        """é¢„è§ˆæ•°æ®é›?""
        dataset = self.get_object()
        try:
            # ç®€å•çš„CSVé¢„è§ˆåŠŸèƒ½
            if dataset.format == 'csv':
                df = pd.read_csv(dataset.file.path, nrows=10)
                preview_data = {
                    'columns': list(df.columns),
                    'data': df.to_dict('records'),
                    'total_rows': len(df),
                    'sample_rows': 10
                }
                return Response(preview_data)
            else:
                return Response({'error': 'æš‚ä¸æ”¯æŒæ­¤æ ¼å¼çš„é¢„è§ˆ'}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
    
    @action(detail=True, methods=['get'])
    def statistics(self, request, pk=None):
        """è·å–æ•°æ®é›†ç»Ÿè®¡ä¿¡æ?""
        dataset = self.get_object()
        try:
            if dataset.format == 'csv':
                df = pd.read_csv(dataset.file.path)
                stats = {
                    'row_count': len(df),
                    'column_count': len(df.columns),
                    'columns': list(df.columns),
                    'data_types': df.dtypes.to_dict(),
                    'missing_values': df.isnull().sum().to_dict(),
                    'basic_stats': df.describe().to_dict() if df.select_dtypes(include=['number']).shape[1] > 0 else {}
                }
                
                # æ›´æ–°æ•°æ®é›†çš„ç»Ÿè®¡ä¿¡æ¯
                dataset.row_count = stats['row_count']
                dataset.schema_info = {
                    'columns': stats['columns'],
                    'data_types': {k: str(v) for k, v in stats['data_types'].items()}
                }
                dataset.save()
                
                return Response(stats)
            else:
                return Response({'error': 'æš‚ä¸æ”¯æŒæ­¤æ ¼å¼çš„ç»Ÿè®¡åˆ†æ'}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


class DataProcessingTaskViewSet(viewsets.ModelViewSet):
    """æ•°æ®å¤„ç†ä»»åŠ¡è§†å›¾é›?""
    queryset = DataProcessingTask.objects.all()
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['task_type', 'status']
    search_fields = ['name', 'description']
    ordering_fields = ['created_at', 'started_at', 'completed_at']
    ordering = ['-created_at']
    
    def get_serializer_class(self):
        if self.action == 'create':
            return DataProcessingTaskCreateSerializer
        return DataProcessingTaskSerializer
    
    def perform_create(self, serializer):
        serializer.save(created_by=self.request.user)
    
    def get_queryset(self):
        return self.queryset.filter(created_by=self.request.user)
    
    @action(detail=True, methods=['post'])
    def execute(self, request, pk=None):
        """æ‰§è¡Œæ•°æ®å¤„ç†ä»»åŠ¡"""
        task = self.get_object()
        
        if task.status != 'pending':
            return Response({'error': 'ä»»åŠ¡çŠ¶æ€ä¸å…è®¸æ‰§è¡Œ'}, status=status.HTTP_400_BAD_REQUEST)
        
        # æ›´æ–°ä»»åŠ¡çŠ¶æ€?
        task.status = 'running'
        task.started_at = timezone.now()
        task.save()
        
        try:
            # ç®€å•çš„æ•°æ®å¤„ç†é€»è¾‘ç¤ºä¾‹
            result = self._process_data(task)
            
            task.status = 'completed'
            task.completed_at = timezone.now()
            task.result_data = result
            task.status_message = 'ä»»åŠ¡æ‰§è¡ŒæˆåŠŸ'
            task.save()
            
            return Response({'message': 'ä»»åŠ¡æ‰§è¡ŒæˆåŠŸ', 'result': result})
            
        except Exception as e:
            task.status = 'failed'
            task.completed_at = timezone.now()
            task.status_message = str(e)
            task.save()
            
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
    
    def _process_data(self, task):
        """ç®€å•çš„æ•°æ®å¤„ç†é€»è¾‘"""
        dataset = task.source_dataset
        config = task.configuration
        
        if task.task_type == 'analysis' and dataset.format == 'csv':
            df = pd.read_csv(dataset.file.path)
            
            result = {
                'row_count': len(df),
                'column_count': len(df.columns),
                'columns': list(df.columns),
                'basic_stats': df.describe().to_dict() if df.select_dtypes(include=['number']).shape[1] > 0 else {},
                'processing_config': config
            }
            return result
        
        return {'message': 'åŸºç¡€å¤„ç†å®Œæˆ', 'config': config}
